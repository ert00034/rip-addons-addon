#!/usr/bin/env node
/*
  Generates RipAddons/data/impacted_addons.lua from a JSON feed.

  Usage:
    node scripts/generate-impacted.js --in <url-or-path> --out RipAddons/data/impacted_addons.lua

  Config via env:
    IMPACTED_FEED_URL, IMPACTED_FEED_URL_VAR (fallback), GITHUB_TOKEN (optional for private GitHub/raw)

  Expected feed formats (flexible):
    1) { version: "YYYY-MM-DD", items: [ { name|folder|slug, severity, note?, link? }, ... ] }
    2) [ { name|folder|slug, severity, note?, link? }, ... ]

  Name normalization rule matches addon logic: lowercase, remove non-alphanumerics.
*/

const fs = require('fs/promises');
const path = require('path');

// Known alias mappings where community slugs differ from addon folder names
// Keys and values are both normalized (lowercase, alphanumerics only)
const ALIAS_MAP = {
  mdt: 'mythicdungeontools',
};

function parseArgs() {
  const args = process.argv.slice(2);
  const out = { in: undefined, out: 'RipAddons/data/impacted_addons.lua' };
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a === '--in' || a === '-i') out.in = args[++i];
    else if (a === '--out' || a === '-o') out.out = args[++i];
  }
  out.in = out.in || process.env.IMPACTED_FEED_URL || process.env.IMPACTED_FEED_URL_VAR;
  if (!out.in) {
    console.error('ERROR: Missing feed source. Provide --in <url-or-path> or set IMPACTED_FEED_URL.');
    process.exit(1);
  }
  return out;
}

function normalizeName(name) {
  return (name || '').toString().toLowerCase().replace(/[^0-9a-z]/gi, '');
}

function applyAlias(normalizedKey) {
  return ALIAS_MAP[normalizedKey] || normalizedKey;
}

function normalizeSeverity(sev) {
  if (!sev) return 'unknown';
  const s = sev.toString().toLowerCase();
  const map = {
    critical: 'critical',
    high: 'high',
    severe: 'high',
    medium: 'medium',
    moderate: 'medium',
    yellow: 'medium',
    low: 'low',
    minor: 'low',
    green: 'low',
    red: 'critical',
    orange: 'high',
  };
  return map[s] || s;
}

function rankSeverity(sev) {
  const s = normalizeSeverity(sev);
  const rank = { critical: 1, high: 2, medium: 3, low: 4, unknown: 9 };
  return rank[s] ?? 9;
}

function luaString(value) {
  if (value == null) return null;
  const s = String(value).replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\r/g, "").replace(/\"/g, '\\"');
  return `"${s}"`;
}

async function readSource(src) {
  if (/^https?:\/\//i.test(src)) {
    const headers = {};
    const token = process.env.GITHUB_TOKEN || process.env.TOKEN;
    if (token) headers['authorization'] = `Bearer ${token}`;
    const res = await fetch(src, { headers });
    if (!res.ok) throw new Error(`HTTP ${res.status} fetching ${src}`);
    return await res.json();
  }
  const data = await fs.readFile(src, 'utf8');
  return JSON.parse(data);
}

function extractItems(json) {
  const items = Array.isArray(json) ? json : Array.isArray(json.items) ? json.items : [];
  const version = (json && json.version) || new Date().toISOString().slice(0, 10);
  return { version, items };
}

function selectNameLike(o) {
  return (
    o.folder || o.addonFolder || o.slug || o.name || o.addonName || o.package || o.id || null
  );
}

function selectNoteLike(o) {
  return o.note || o.reason || o.message || o.summary || null;
}

function selectLinkLike(o) {
  return o.link || o.url || o.article || o.permalink || null;
}

function buildAddonsMap(items) {
  const map = new Map();
  for (const it of items) {
    const rawName = selectNameLike(it);
    let key = normalizeName(rawName);
    if (!key) continue;
    key = applyAlias(key);
    const sev = normalizeSeverity(it.severity || it.level || it.impact || it.rank);
    const note = selectNoteLike(it);
    const link = selectLinkLike(it);

    const existing = map.get(key);
    if (!existing) {
      map.set(key, { severity: sev, note, link });
    } else {
      // Keep highest severity
      if (rankSeverity(sev) < rankSeverity(existing.severity)) {
        existing.severity = sev;
      }
      // Prefer non-empty note/link
      if (!existing.note && note) existing.note = note;
      if (!existing.link && link) existing.link = link;
    }
  }
  return map;
}

function toLuaTable(version, map) {
  const keys = Array.from(map.keys()).sort((a, b) => a.localeCompare(b));
  const lines = [];
  lines.push('-- Generated by scripts/generate-impacted.js');
  lines.push(`-- Source: ${new Date().toISOString()}`);
  lines.push('');
  lines.push('RipAddons_ImpactedData = {');
  lines.push(`  version = ${luaString(version)},`);
  lines.push('  addons = {');
  for (const k of keys) {
    const v = map.get(k);
    const parts = [`severity = ${luaString(v.severity)}`];
    if (v.note) parts.push(`note = ${luaString(v.note)}`);
    if (v.link) parts.push(`link = ${luaString(v.link)}`);
    lines.push(`    [${luaString(k)}] = { ${parts.join(', ')} },`);
  }
  lines.push('  }');
  lines.push('}');
  lines.push('');
  return lines.join('\n');
}

async function main() {
  const args = parseArgs();
  const src = args.in;
  const outFile = args.out;

  const json = await readSource(src);
  const { version, items } = extractItems(json);
  const map = buildAddonsMap(items);
  await fs.mkdir(path.dirname(outFile), { recursive: true });
  const lua = toLuaTable(version, map);
  await fs.writeFile(outFile, lua, 'utf8');
  console.log(`Wrote ${outFile} with ${map.size} entries (version ${version}).`);
}

main().catch((err) => {
  console.error(err.stack || err.message || String(err));
  process.exit(1);
});


